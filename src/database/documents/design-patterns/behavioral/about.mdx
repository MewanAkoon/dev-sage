# Behavioral Design Patterns

Behavioral design patterns are concerned with algorithms and the assignment of responsibilities between objects. They help make the interactions between objects easier, ensuring that they do not depend on each other explicitly.

## Introduction

Behavioral patterns are vital for enhancing communication between disparate objects in a system. They help in defining how objects interact in a manner that increases the flexibility in carrying out communication.

## Patterns

### Command

The Command pattern encapsulates a request as an object, thereby allowing for parameterization of clients with different requests, and support for undoable operations.

- **Intent**: Encapsulate a request as an object.
- **Applicability**: Use the Command pattern when you want to parameterize objects with operations, or when you need to queue operations, track log operations, or support undoable operations.
- **Example**: In a document editing application, commands can encapsulate different editing actions like add text, remove text, and modify text. Each command supports undo functionality, allowing users to revert their actions.

### Iterator

The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

- **Intent**: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
- **Applicability**: Use the Iterator pattern to allow traversal of different aggregate structures or to provide a uniform interface for traversing different aggregate structures.
- **Example**: A playlist can be iterated in different orders (forward or reverse) using an iterator interface, allowing the user to traverse through a collection of songs without knowing the underlying structure of the playlist.

### Mediator

The Mediator pattern defines an object that encapsulates how a set of objects interact. This pattern promotes loose coupling by keeping objects from referring to each other explicitly.

- **Intent**: Encapsulate how a set of objects interact.
- **Applicability**: Use the Mediator pattern to reduce the coupling between classes that communicate with each other. Instead of classes communicating directly, and thus having a high degree of coupling, they communicate indirectly through a mediator.
- **Example**: In a chat application, a `ChatRoom` mediator allows multiple users to communicate by passing messages between them, without any direct coupling between the `User` objects.

### Observer

The Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

- **Intent**: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
- **Applicability**: Use the Observer pattern in any scenario where an abstraction has two aspects, one dependent on the other. Encapsulating these aspects in separate objects lets you vary and reuse them independently.
- **Example**: A weather monitoring system uses the Observer pattern where the `WeatherStation` acts as the subject. It notifies all registered displays (`Observers`) when the temperature changes so they can update their displays accordingly.

### State

The State pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.

- **Intent**: Allow an object to alter its behavior when its internal state changes. The object appears to change its class.
- **Applicability**: Use the State pattern when an object's behavior depends on its state, and it must change its behavior at runtime depending on that state.
- **Example**: A document editor can change its behavior based on its state, switching between different modes such as editing, viewing, and previewing, each state providing different behavior for the same operations.

## Conclusion

Behavioral design patterns are essential for managing inter-object communications. They help in making the system easier to manage and more scalable, enabling objects to interact in a way that reduces dependencies and enhances flexibility.
