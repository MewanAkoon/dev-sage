# Design Patterns

Design patterns are typical solutions to common problems in software design. They are like pre-made blueprints you can customize to solve a particular design problem in your code.

## Creational Patterns: How objects are created

### Constructor

The Constructor Pattern in TypeScript is used to create new objects with specific initial values and methods. It's a fundamental mechanism provided by class-based object-oriented programming languages to instantiate objects.

### Singleton

Ensures that a class has only one instance, and provides a global point of access to it. This is particularly useful when exactly one object is needed to coordinate actions across the system.

### Prototype

Creates new objects by copying an existing object, known as the prototype. This is useful when the cost of creating an object is more expensive or complex than copying an existing one.

### Builder

Allows constructing complex objects step by step. The Builder Pattern is useful when an object needs to be initialized with numerous fields, some of which may have default values.

### Factory

Defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Methods let a class defer instantiation to subclasses.

## Structural Patterns: How objects relate to each other

### Facade

Provides a simplified interface to a complex subsystem. Facades help to minimize the communication and dependencies between subsystems.

### Proxy

Provides a placeholder for another object to control access to it. This is useful for controlling the resource footprint of object creation, access control, or adding other functionalities such as logging or lazy initialization.

### Adapter

Allows objects with incompatible interfaces to collaborate. The Adapter Pattern is like a bridge between two incompatible interfaces.

### Decorator

Allows for the dynamic addition of responsibilities to objects without modifying their existing code. This pattern is useful for adhering to the Open/Closed Principle, one of the SOLID principles.

## Behavioral Patterns: How objects communicate with each other

### Iterator

Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

### Observer

Defines a dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

### Mediator

Defines an object that encapsulates how a set of objects interact. The Mediator Pattern promotes loose coupling by keeping objects from referring to each other explicitly.

### State

Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.

### Strategy

Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

### Command

Encapsulates a request as an object, thereby allowing users to parameterize clients with queues, requests, and operations. It supports undoable operations.

---

## Resources

- [Refactoring GURU](https://refactoring.guru/design-patterns)
