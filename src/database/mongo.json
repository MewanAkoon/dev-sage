[
	{
		"question": "What is MongoDB and what is it primarily used for?",
		"answer": "MongoDB is a NoSQL database designed for scalability and flexibility. It uses a document-oriented data model, making it ideal for applications that require rapid development, flexible data structures, and the ability to scale horizontally. MongoDB is commonly used for storing large volumes of data in formats that vary from traditional table-based relational databases.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "How does MongoDB store data?",
		"answer": "MongoDB stores data in BSON (Binary JSON) documents. BSON is a binary-encoded serialization of JSON-like documents which allows MongoDB to support additional data types not typically available in JSON, such as date and binary data types.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "Explain what a collection is in MongoDB.",
		"answer": "In MongoDB, a collection is a grouping of MongoDB documents. It is equivalent to a table in relational databases. Collections exist within a single database. Collections do not enforce a schema, meaning documents within the same collection can have different fields and structures.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "What is a document in MongoDB?",
		"answer": "A document in MongoDB is a basic unit of data, similar to a row in relational databases. Each document is a BSON object that can have one or more key-value pairs as its data fields. Documents are stored in collections and can have a dynamic schema that does not require that all documents have the same structure.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "Can you compare MongoDB databases with traditional relational databases in terms of schema requirements?",
		"answer": "Traditional relational databases require a defined schema based on tables and rows, and modifications to the schema involve altering the database structure. MongoDB operates on a flexible schema model where each document can store different data types and structures, allowing for more flexibility and ease in handling diverse data types and rapid application development.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "What is meant by 'schemaless' in MongoDB?",
		"answer": "Schemaless, in the context of MongoDB, refers to the capability to store different types of data and structures in the same database or even in the same collection without a predefined schema format. This allows the documents to have any number of fields and complexity, which can vary from one document to another.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "What types of indexes does MongoDB support?",
		"answer": "MongoDB supports several types of indexes that enhance query performance. These include single field indexes, compound indexes (index on multiple fields), text indexes (for full-text search), and geospatial indexes (for geo queries), among others.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "Describe the role of the '_id' field in MongoDB documents.",
		"answer": "The '_id' field in a MongoDB document acts as a primary key to uniquely identify the document within its collection. It is automatically added to each document if not specified and typically stores a unique ObjectId, which is a 12-byte BSON type. The ObjectId is designed to be unique across documents and can be used to quickly locate documents.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "How does MongoDB handle transactions?",
		"answer": "MongoDB supports multi-document transactions, which are similar to traditional ACID transactions. As of MongoDB 4.0 and later, transactions can be used across multiple operations, collections, databases, and documents, ensuring atomicity, consistency, isolation, and durability (ACID).",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "Explain the concept of sharding in MongoDB.",
		"answer": "Sharding in MongoDB is a method for distributing data across multiple servers or clusters. This approach helps manage large data sets and provides high throughput operations by breaking up the data into smaller chunks or shards, which are distributed and managed across multiple physical locations. Sharding improves performance and scalability as the database grows.",
		"difficulty": 0,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "Explain the difference between MongoDB and MySQL.",
		"answer": "MongoDB is a NoSQL, document-oriented database that uses BSON format for storing data, suitable for hierarchical storage needs and schema-less data models. MySQL is a relational database that uses structured query language (SQL) for managing data, which requires predefined schemas and is less flexible in terms of data format. MongoDB generally offers better performance for large datasets and horizontal scaling scenarios compared to MySQL.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "What is a replica set in MongoDB?",
		"answer": "A replica set in MongoDB is a group of mongod instances that maintain the same data set. Replica sets provide redundancy and high data availability. They are the cornerstone of MongoDB's high availability and data redundancy features, as they allow automatic failover and data recovery mechanisms.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "How does MongoDB ensure index efficiency?",
		"answer": "MongoDB ensures index efficiency by using B-tree data structures, allowing quick search, insert, and delete operations. Efficient indexes reduce the need for full collection scans and improve query performance by only scanning the relevant parts of the data. Proper index management, such as creating compound indexes and considering the order of fields in indexes, is crucial for optimizing query performance.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "Explain the write concern in MongoDB.",
		"answer": "Write concern in MongoDB defines the level of assurance for data durability when performing write operations. It specifies the number of replica set members that must acknowledge the write before considering the operation successful. This setting can be configured to balance between performance and reliability, depending on the needs of the application.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "What are the implications of embedding documents versus referencing them in MongoDB?",
		"answer": "Embedding documents in MongoDB provides faster read operations by reducing the need for joins. However, it may lead to data duplication and larger document sizes. Referencing documents, on the other hand, normalizes data but requires additional read operations to resolve references. Choosing between embedding and referencing depends on the specific application's query patterns and data usage.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Discuss the role of the 'majority' keyword in the context of write concerns in MongoDB.",
		"answer": "The 'majority' keyword in MongoDB's write concerns ensures that the data has been written to the majority of the nodes in a replica set before acknowledging a write operation. This provides protection against data loss in the event of a node failure, as the majority of nodes have a consistent copy of the data.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "How does the aggregation framework work in MongoDB?",
		"answer": "The aggregation framework in MongoDB processes data records and returns computed results. It provides a pipeline-based mechanism where data passes through multiple stages, each transforming it in some manner. Common stages include filtering (using $match), projecting ($project), grouping ($group), and sorting ($sort). This framework is powerful for complex data analysis and transformation tasks.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "What is a covered query in MongoDB?",
		"answer": "A covered query in MongoDB is a query that can be satisfied entirely using an index without needing to look up the actual documents. Covered queries are highly efficient as they avoid the cost of reading documents from the disk, leading to faster query performance.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "Describe how MongoDB handles large data objects or files.",
		"answer": "MongoDB handles large data objects or files using GridFS, a specification for storing and retrieving files that exceed the BSON-document size limit of 16MB. GridFS divides a file into chunks and stores each chunk as a separate document, allowing efficient storage and retrieval of large files without hitting document size limits.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "What are capped collections in MongoDB?",
		"answer": "Capped collections in MongoDB are fixed-size collections that maintain insertion order. They are particularly useful for use cases like logging or caching where old data can be overwritten by new data when the specified size limit is reached. This feature provides high-performance and predictable insertion order due to the nature of their underlying storage.",
		"difficulty": 1,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "Discuss the journaling process in MongoDB and its impact on data durability.",
		"answer": "Journaling in MongoDB is a mechanism that helps ensure data durability by writing changes to a separate on-disk journal before they are applied to the data files. In case of a crash, the journal can be used to recover uncommitted changes that were in progress at the time of the crash. This process is crucial for maintaining data integrity and preventing data loss.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Explain the concept of 'oplog' in MongoDB replication.",
		"answer": "The oplog (operations log) is a special capped collection in MongoDB used in replica sets to record all modifications to the database. Each replica set member has its own oplog, allowing for replication of operations across all nodes. This log plays a critical role in ensuring that all data on replica set members are consistent, by replaying operations in the same order they were originally executed.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "How does MongoDB handle locking at the document level?",
		"answer": "MongoDB implements document-level locking which allows concurrent operations to occur on separate documents without locking the entire collection or database. This fine-grained locking mechanism enhances concurrency and performance by reducing contention and wait times associated with locks.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "Describe the sharding process in MongoDB and how it contributes to database scalability.",
		"answer": "Sharding in MongoDB is a method for distributing data across multiple machines to support deployments with very large data sets and high throughput operations. By splitting data into smaller, more manageable pieces, called shards, MongoDB can provide horizontal scalability and distribute load more evenly. This process is managed through a sharding key, which determines how data is distributed across the shards.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "What are the challenges associated with sharded environments in MongoDB?",
		"answer": "Sharded environments in MongoDB face challenges such as complexity in configuration and maintenance, balancing data evenly across shards, and potential performance bottlenecks if the sharding key is not chosen wisely. Additionally, ensuring consistency across shards and managing failover and recovery in a sharded cluster add to the operational overhead.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Explain how MongoDB's WiredTiger storage engine differs from MMAPv1.",
		"answer": "MongoDB's WiredTiger storage engine offers significant improvements over the older MMAPv1, including support for document-level locking (as opposed to collection-level locking in MMAPv1), compression for data and indexes, and better overall performance, especially under write-heavy workloads. WiredTiger is designed to be more efficient in handling concurrent operations and large datasets.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Discuss the impact of read and write concerns on data consistency in MongoDB.",
		"answer": "Read and write concerns in MongoDB dictate the level of consistency and reliability for database operations. Write concerns specify how many replica set members must confirm a write operation before it is considered successful, impacting data durability. Read concerns determine the freshness of the data read, influencing data consistency across the database. Configuring these concerns properly is crucial for achieving the desired balance between performance and consistency.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "How does MongoDB optimize queries?",
		"answer": "MongoDB optimizes queries through effective use of indexes, query planning, and the execution of stages in the aggregation framework. It uses a query optimizer that evaluates different query plans and selects the most efficient one. Proper indexing is critical, as MongoDB can then use these indexes to limit the number of documents it must scan, thereby improving query performance significantly.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "What is the role of the balancer in MongoDB's sharded architecture?",
		"answer": "The balancer in MongoDB's sharded architecture is responsible for distributing data evenly across the shards. It monitors the data distribution and performs automatic shard balancing operations by moving data chunks from one shard to another to ensure even load distribution and optimal use of resources across the sharded cluster.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Explain the significance of the aggregation pipeline in MongoDB.",
		"answer": "The aggregation pipeline in MongoDB allows for complex data transformations and analysis through a multi-stage pipeline. Each stage processes the data sequentially and passes its output to the next stage, similar to a Unix-like pipeline. This methodology allows for efficient data processing and aggregation, enabling sophisticated querying and analytical capabilities within MongoDB.",
		"difficulty": 2,
		"practicality": 0,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "How do you create a new database in MongoDB?",
		"answer": "To create a new database in MongoDB, use the `use` command followed by the database name. For example, `use myNewDatabase` switches to `myNewDatabase`. If it does not exist, MongoDB will create it when you first store data in that database (e.g., create the first collection).",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "What command is used to show all databases in a MongoDB server?",
		"answer": "To list all databases on a MongoDB server, you can use the `show dbs` command in the mongo shell. This command displays all databases along with their current sizes.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 3,
		"resources": []
	},
	{
		"question": "How would you insert a document into a MongoDB collection?",
		"answer": "To insert a document into a MongoDB collection, use the `insertOne()` method for a single document or `insertMany()` for multiple documents. For example, `db.collectionName.insertOne({name: 'John', age: 30})` inserts a single document into `collectionName`.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "What is the default port for the MongoDB server?",
		"answer": "The default port used by the MongoDB server is 27017. This port is used when connecting through various MongoDB clients unless specified otherwise.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 2,
		"resources": []
	},
	{
		"question": "Explain how to find a specific document in a collection by a field.",
		"answer": "To find a document in a MongoDB collection based on a specific field, use the `find()` method with a query object specifying the field and value. For example, `db.collectionName.find({name: 'John'})` retrieves documents where the name field is 'John'.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "How can you update a document in MongoDB?",
		"answer": "To update a document in MongoDB, use the `updateOne()` method or `updateMany()` if you want to update multiple documents. For example, `db.collectionName.updateOne({name: 'John'}, {$set: {age: 31}})` updates the age of a document with the name 'John'.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "Describe how to delete a document from a MongoDB collection.",
		"answer": "To delete a document in MongoDB, use the `deleteOne()` method for a single document or `deleteMany()` to remove multiple documents. For instance, `db.collectionName.deleteOne({name: 'John'})` deletes a single document where the name is 'John'.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "How do you add an index to a collection in MongoDB and why would you do this?",
		"answer": "To add an index to a MongoDB collection, use the `createIndex()` method. For example, `db.collectionName.createIndex({name: 1})` creates an ascending index on the name field. Indexes improve the efficiency of data retrieval but may reduce write performance and increase storage requirements.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "What is the purpose of the `limit()` method in MongoDB?",
		"answer": "The `limit()` method in MongoDB is used to specify the maximum number of documents the query should return. This is useful for paging through large sets of data. For example, `db.collectionName.find().limit(10)` retrieves the first 10 documents from `collectionName`.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 3,
		"resources": []
	},
	{
		"question": "Explain how to use the `sort()` method in MongoDB.",
		"answer": "The `sort()` method in MongoDB is used to sort the result of a query. You can specify the field and direction (ascending or descending) of sorting. For example, `db.collectionName.find().sort({age: 1})` sorts documents by the age field in ascending order.",
		"difficulty": 0,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "How do you handle transactions in MongoDB?",
		"answer": "To handle transactions in MongoDB, start a session and then start a transaction within this session. Use `session.startTransaction()`, followed by your operations, and commit with `session.commitTransaction()` or abort with `session.abortTransaction()` if necessary. Transactions are useful when you need to perform multiple operations atomically.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Explain the use of the `$lookup` stage in MongoDB's aggregation framework.",
		"answer": "The `$lookup` stage in MongoDB's aggregation framework performs a left outer join to a second collection in the same database to filter in documents from the joined collection for processing. It allows you to aggregate data from multiple collections into a single result—useful for merging related data stored in separate collections.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Describe how to optimize a query in MongoDB.",
		"answer": "To optimize a query in MongoDB, ensure that you use indexes effectively. Use the `explain()` method to analyze the performance of your queries. It provides details on whether your query uses an index or performs a full collection scan, helping you decide how to adjust your indexing strategy for better performance.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "How can you configure read preferences in a MongoDB replica set?",
		"answer": "Read preferences in MongoDB allow you to specify the preferred replica set members from which to read data. These can be set to primary, secondary, nearest, etc., depending on your application's needs for consistency and read distribution. Configuring read preferences helps manage how read operations are balanced across the replica set.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 8,
		"resources": []
	},
	{
		"question": "What is sharding, and how is it implemented in MongoDB?",
		"answer": "Sharding is a method of distributing data across multiple servers or clusters to manage large datasets and high throughput operations. In MongoDB, sharding is implemented by partitioning data into shards, each managed by a separate mongod instance. A shard key determines the distribution of data. Configuring sharding involves setting up shard clusters, choosing a shard key, and enabling sharding on your collections.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 12,
		"resources": []
	},
	{
		"question": "How do you perform backup and recovery in MongoDB?",
		"answer": "Backup and recovery in MongoDB can be performed using various methods including mongodump for creating backups, and mongorestore for restoring data from these backups. For continuous backup, use MongoDB’s oplog along with custom scripts or third-party tools that support point-in-time recovery, ensuring minimal downtime and data loss.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 12,
		"resources": []
	},
	{
		"question": "Explain the difference between `$project` and `$group` stages in the aggregation pipeline.",
		"answer": "In MongoDB's aggregation pipeline, `$project` is used to select some fields, add new fields, or rename fields in a document. `$group` aggregates documents by some specified expression and can output to a grouped format, often used to calculate counts, sums, averages, etc. Both stages are crucial for transforming documents into an aggregated format.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Discuss the use of the WiredTiger storage engine in MongoDB.",
		"answer": "The WiredTiger storage engine is the default storage engine in MongoDB versions 3.2 and above. It offers benefits like support for document-level concurrency, compression to save storage space, and is more efficient in handling large data volumes with high write loads compared to older engines like MMAPv1.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "How do you use the `mongoexport` and `mongoimport` tools?",
		"answer": "The `mongoexport` tool is used to export data from MongoDB collections into JSON or CSV files, while `mongoimport` allows importing data from JSON or CSV files into MongoDB collections. These tools are handy for data migration, backups, or when transferring data between systems not directly connected.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "What are some best practices for securing a MongoDB database?",
		"answer": "Best practices for securing MongoDB include enabling authentication, using role-based access control, encrypting network traffic using TLS/SSL, encrypting data at rest, auditing database activity, configuring firewalls to limit access, and keeping the MongoDB software up to date to protect against vulnerabilities.",
		"difficulty": 1,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Explain how to set up and configure a MongoDB sharded cluster.",
		"answer": "Setting up a MongoDB sharded cluster involves configuring multiple components: config servers to store cluster's metadata, shard servers to store actual data, and query routers (mongos) to interface with client applications. Initialize the config servers, add shards to the cluster, and connect mongos instances. Choose an appropriate shard key to ensure even distribution and scalability.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "Discuss strategies for managing data growth in a MongoDB database.",
		"answer": "Managing data growth in MongoDB can involve implementing sharding to distribute data across multiple servers, archiving old data, optimizing current indexes, and considering the use of capped collections for log-like data. Regularly monitoring disk space and performance metrics helps in making informed decisions about scaling and data management.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "How do you ensure high availability in a MongoDB environment?",
		"answer": "Ensure high availability in MongoDB by using replica sets, which provide automatic failover and data redundancy. Configure an odd number of replica set members or use an arbiter to avoid split-brain scenarios. Regularly test failover scenarios to ensure the system meets the required recovery time objectives (RTO) and recovery point objectives (RPO).",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "Explain advanced indexing strategies in MongoDB for complex queries.",
		"answer": "Advanced indexing strategies in MongoDB include using compound indexes, partial indexes, and text indexes to optimize query performance. Compound indexes can speed up queries that match multiple criteria, partial indexes index only a subset of documents meeting a filtering criterion, and text indexes support searching for text within strings across multiple fields.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "How can you monitor and diagnose performance issues in MongoDB?",
		"answer": "Monitor MongoDB performance using the MongoDB Atlas platform, command-line tools like `mongostat` and `mongotop`, or third-party monitoring solutions. Regularly review the performance metrics and logs to identify slow queries, hardware bottlenecks, or inefficient use of resources. Use the `explain()` method to analyze and optimize query execution plans.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "Discuss the implications of choosing a shard key and methods to alter it post-implementation.",
		"answer": "Choosing an effective shard key is crucial as it affects the distribution of data across shards and overall cluster performance. Poor choices can lead to shard imbalances and hotspots. Altering a shard key post-implementation is complex and usually involves creating a new collection with a new shard key and migrating data. Planning and testing shard key strategies before implementation is critical.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "Describe the process of scaling a MongoDB database both vertically and horizontally.",
		"answer": "Scaling MongoDB vertically involves adding more resources (CPU, RAM, storage) to existing servers. Horizontally, or scaling out, involves adding more servers to a replica set or sharding the data across multiple machines. While vertical scaling is simpler, horizontal scaling offers greater scalability and is generally recommended for large, distributed applications.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "Explain how to configure and use MongoDB's change streams feature.",
		"answer": "Change streams in MongoDB allow applications to access real-time data changes without complexity and risk of tailing the oplog. Configure change streams by opening a change stream cursor on a collection, database, or deployment, and listen for changes like insert, update, delete, or replace events. This is useful for real-time analytics, triggering actions on data changes, and syncing data across applications.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "How do you manage and mitigate schema changes in a non-relational database like MongoDB?",
		"answer": "Manage schema changes in MongoDB by carefully planning the changes, using schema validation to enforce new data rules, and updating application code to accommodate changes. Utilize MongoDB's flexibility to gradually introduce new fields and deprecate old ones without immediate impact on existing operations. Tools like MongoDB Compass can help visualize and manage schema changes.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "Discuss the best practices for data modeling in MongoDB.",
		"answer": "Best practices for data modeling in MongoDB include understanding the application's access patterns to effectively structure data. Use embedding for high-performance reads, reference documents for data integrity, and optimize document growth patterns to minimize document relocations. Regularly evaluate the model as application requirements evolve to ensure optimal performance and scalability.",
		"difficulty": 2,
		"practicality": 1,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "Imagine you have a collection of customer data and you want to find all customers who live in 'New York'. How would you write this query in MongoDB?",
		"answer": "To find all customers living in 'New York', you would use the `find()` method on your customers collection like this: `db.customers.find({city: 'New York'})`. This query checks the 'city' field for each document and returns those where the city is 'New York'.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "You need to add a new field called 'membershipStatus' to all documents in a customer database, setting it initially to 'active'. What MongoDB operation would you use?",
		"answer": "To add a new field 'membershipStatus' to all documents and set it to 'active', you would use the `updateMany()` method with an empty query object (to match all documents) and the `$set` operator. The command would look like this: `db.customers.updateMany({}, {$set: {membershipStatus: 'active'}})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "If a document in the products collection is structured like `{ name: 'Laptop', price: 799 }`, how would you update the price to 749?",
		"answer": "To update the price of the 'Laptop' to 749, you would use the `updateOne()` method with a query to match the product by name, and the `$set` operator to change the price. The command would be: `db.products.updateOne({name: 'Laptop'}, {$set: {price: 749}})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "A document in your 'orders' collection incorrectly lists a product's price as 0. The correct price is 20. How would you correct this error?",
		"answer": "To correct the price error, use the `updateOne()` method to find the order with the price listed as 0 and update it to 20. The MongoDB command would be: `db.orders.updateOne({price: 0}, {$set: {price: 20}})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "You want to delete all documents in the 'sessions' collection that are older than one year. Assuming each document has a 'createdAt' date field, how would you achieve this?",
		"answer": "To delete sessions older than one year, you would use the `deleteMany()` method with a query that uses the `$lt` (less than) operator on the 'createdAt' field, comparing it to a date one year ago. Here’s how you could write it: `db.sessions.deleteMany({createdAt: {$lt: new Date(new Date().setFullYear(new Date().getFullYear() - 1))}})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "A user named 'John Doe' needs to change his username to 'JohnD'. How would you update this information in the database?",
		"answer": "To change 'John Doe''s username to 'JohnD', use the `updateOne()` method to locate his current username and modify it. The command would be: `db.users.updateOne({username: 'John Doe'}, {$set: {username: 'JohnD'}})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "How would you find all products in a collection that have a price greater than $50 and sort them by price in descending order?",
		"answer": "To find and sort products priced over $50 in descending order, use the `find()` method combined with the `sort()` method. The MongoDB command is: `db.products.find({price: {$gt: 50}}).sort({price: -1})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "A customer needs all her contact information deleted from your database for privacy reasons. How would you ensure all her data is removed?",
		"answer": "To fully remove a customer's contact information for privacy, use the `deleteOne()` or `deleteMany()` method, depending on how the data is structured. If all her information is in a single document, `deleteOne()` would suffice. For example: `db.customers.deleteOne({name: 'Her Name'})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "If you need to list all transactions from the last 30 days, assuming each transaction has a 'date' field, how would you write this query?",
		"answer": "To list transactions from the last 30 days, use the `find()` method with the `$gte` operator on the 'date' field to get dates greater than or equal to 30 days ago. Example: `db.transactions.find({date: {$gte: new Date(new Date().setDate(new Date().getDate() - 30))}})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "How would you count the number of documents in a 'messages' collection where the 'status' field is 'unread'?",
		"answer": "To count documents where the 'status' is 'unread', use the `countDocuments()` method with a query. The command would be: `db.messages.countDocuments({status: 'unread'})`.",
		"difficulty": 0,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 5,
		"resources": []
	},
	{
		"question": "You are designing a feature for a social media app that loads user posts. What MongoDB operation would you use to implement pagination of posts?",
		"answer": "To implement pagination of user posts in MongoDB, you would use the `skip()` and `limit()` methods together with your query. For example, to get the second page of results with 10 posts per page, you could use: `db.posts.find().skip(10).limit(10)`.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 7,
		"resources": []
	},
	{
		"question": "Your application experiences a high read load on a user profile collection during peak hours. How would you optimize read performance in MongoDB?",
		"answer": "To optimize read performance during peak hours, consider implementing read replicas and proper indexing. Read replicas can handle read requests, reducing load on the primary server. Ensure that user profiles are indexed on frequently accessed fields to reduce the need for full collection scans.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "A new regulation requires that all user data in the 'users' collection older than 5 years must be archived and removed from active databases. How would you handle this requirement?",
		"answer": "To comply with the regulation, use the `find()` method to identify users with data older than 5 years, export this data for archiving using `mongoexport`, and then delete the data from the active database using `deleteMany()`. For example, find and archive: `db.users.find({createdAt: {$lt: new Date(new Date().setFullYear(new Date().getFullYear() - 5))}})`.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 12,
		"resources": []
	},
	{
		"question": "How would you restore a MongoDB database from a backup in a disaster recovery scenario?",
		"answer": "In a disaster recovery scenario, use `mongorestore` to restore the database from a backup file. Ensure MongoDB is running, and execute `mongorestore` with the path to your backup data. Adjust connection parameters as needed based on your environment setup.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "Your team plans to migrate data from an old customer database to MongoDB. Describe the steps and considerations for this migration.",
		"answer": "For migrating data to MongoDB, first, analyze the data structure of the old database and map how it will translate to MongoDB's document model. Use tools like `mongoimport` for importing data. Consider the need for data transformation and ensure indexes are created post-migration to optimize query performance.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "Describe a method to synchronize MongoDB data with a SQL database in real-time.",
		"answer": "To synchronize MongoDB data with a SQL database in real-time, use change streams in MongoDB to capture changes and a middleware service or ETL tool to apply these changes to the SQL database. This setup requires careful error handling and back-pressure management to handle synchronization failures.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "Your application must handle multi-lingual text searches. How can you configure MongoDB to support this?",
		"answer": "To support multi-lingual text searches in MongoDB, use text indexes that include a language override field. Configure the text index with the `default_language` option to handle multiple languages and use the `$text` query operator with the `$search` parameter to perform text searches across the specified fields.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "If a MongoDB shard becomes corrupt, what steps would you take to recover the data and ensure the cluster remains balanced?",
		"answer": "In the event of a shard corruption, first isolate the affected shard to prevent further data corruption. Use backups to restore the data on the shard. Rebalance the cluster by redistributing the data across the remaining shards to maintain load distribution and system integrity.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "How would you automate periodic MongoDB backups?",
		"answer": "Automate periodic MongoDB backups by setting up a cron job or a scheduled task that runs `mongodump` to create backups at regular intervals. Store the backups in a secure location and ensure they are accessible for recovery tests to validate backup integrity.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 10,
		"resources": []
	},
	{
		"question": "What strategy would you use to efficiently store and query time-series data in MongoDB?",
		"answer": "For time-series data in MongoDB, utilize the time-series collections feature available in recent versions. This optimizes storage for time-stamped data and improves query efficiency. Ensure that data is indexed on time fields and consider bucketing data based on time intervals for efficient aggregation and retrieval.",
		"difficulty": 1,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 12,
		"resources": []
	},
	{
		"question": "You need to design a system to manage a high volume of real-time event data in MongoDB, ensuring that the system can scale effectively. What architecture and features of MongoDB would you leverage?",
		"answer": "For managing high-volume real-time event data, design a sharded cluster architecture to distribute the data across multiple servers. Use the capped collections to handle high-throughput writes and ensure data expires automatically. Leverage change streams to process events in real-time and consider using WiredTiger's concurrency and compression features for performance optimization.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "Your application has a global user base, and you need to ensure low-latency access to user data from multiple geographic regions. How would you configure MongoDB to meet this requirement?",
		"answer": "Configure a geographically distributed MongoDB replica set to serve global users. Each region would have its own replica set member(s) to ensure low-latency access. Use read preferences to direct read operations to the nearest replica. Consider using sharding with zone sharding to partition data based on region.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "Describe a strategy to handle a scenario where your MongoDB cluster must handle 10x the normal load unexpectedly.",
		"answer": "In scenarios of unexpected load increases, ensure that MongoDB's cluster is configured with sufficient resources to scale horizontally (add more shards) or vertically (increase server specifications). Implement robust monitoring to detect performance bottlenecks early and use connection pooling on the application side to manage increased connections efficiently.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "A critical MongoDB cluster is experiencing intermittent outages. What steps would you take to diagnose and resolve the issue?",
		"answer": "To diagnose and resolve intermittent outages in a MongoDB cluster, start with a thorough review of logs to identify any patterns or errors. Use monitoring tools to track system metrics and performance bottlenecks. Check for hardware failures, network issues, or configuration errors. Apply necessary patches, adjust configurations, or scale resources as needed to stabilize the cluster.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "How would you design a MongoDB schema to optimize operations for a heavily read-centric application?",
		"answer": "For a read-centric application, design the MongoDB schema to minimize read operations' latency and maximize efficiency. Use denormalization to reduce the need for joins. Optimize document structure to align with query patterns, ensuring that most queries access only a single document. Use indexes strategically to cover the most frequent queries.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "Discuss a comprehensive backup strategy for a MongoDB deployment handling sensitive data.",
		"answer": "For sensitive data, implement an encrypted backup solution using `mongodump` with encryption at rest. Schedule regular backups, ensuring they are stored in multiple secure locations. Test recovery processes regularly to ensure data integrity and availability. Consider using MongoDB Atlas for automated backups and VPC peering for secure backup storage.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "You discover that a MongoDB index is causing performance degradation. How would you assess and remediate this issue?",
		"answer": "To assess the impact of a problematic index, use the `explain()` function to analyze query performance and index usage. If the index is found to be inefficient or unnecessary, consider dropping the index or replacing it with a more optimal one. Monitor performance before and after the change to ensure that the modification has a positive effect.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "Explain how you would migrate a large MongoDB database to a new data center with minimal downtime.",
		"answer": "To migrate a large MongoDB database with minimal downtime, set up a replica set in the new data center. Synchronize data between the old and new locations until the new data center is fully up to date. During a planned maintenance window, switch over to the new data center by reconfiguring the application to point to the new MongoDB servers. Ensure all data is consistent before decommissioning the old data center.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	},
	{
		"question": "What recent feature in MongoDB has significantly impacted your work, and how have you applied it?",
		"answer": "A recent significant feature in MongoDB is the support for multi-document ACID transactions. This feature has allowed for more complex operations that maintain data integrity across multiple documents and collections. I've applied this in financial applications where atomic updates across multiple records are crucial, such as adjusting balances and logging transactions simultaneously.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 15,
		"resources": []
	},
	{
		"question": "How would you handle versioning of documents in MongoDB for a document history feature?",
		"answer": "To implement document versioning in MongoDB, use a combination of the `$currentDate`, `$inc`, and `$set` operators to maintain a version field and historical data within each document. Alternatively, create a separate collection to store historical versions of documents, using triggers or application logic to capture changes whenever documents are updated.",
		"difficulty": 2,
		"practicality": 2,
		"tags": [],
		"estimatedTime": 20,
		"resources": []
	}
]
